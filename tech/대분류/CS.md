서버 / 클라이언트

클라이언트 : 웹 브라우저와같이 어떠한 정보를 요청하는 시스템

서버 : (서빙이 음식 등을 제공하다라는 뜻인 것처럼) 웹 브라우저가 요청한 정보를 제공하는 쪽. 서버쪽에서 웹과 관련된 정보를 제공하는것을 웹서버라고 하고,
웹서버는 보통 일반적으로 그 웹서비스를 제공하는 컴퓨터를 의미하기도 하고, 또 그 컴퓨터 위에서 그러한 동작을 수행하도록 만들어진 소프트웨어를 웹서버라고도 함

----------------------------------------------------------------------------------------------------

Restful API

GET / POST / PUT / DELETE 로 구분해서 소프트웨어 또는 컴포넌트 또는 시스템 간에 데이터 및 기능을 교환하고 상호작용 할 수 있는 방법을 제공하는것

GET : 주로 서버로부터 리소스를 가져오기 위해 씀. 일반적으로 쿼리스트링을 써서 데이터를 전달함 (RequestBody X)
POST : 서버에 새로운 데이터를 전송하거나 리소스를 생성할때 씀
PUT : 지정한 리소스 전체를 업데이트할때 씀
DELETE : 지정한 리소스를 삭제할때 씀 (RequestBody X)
HEAD : GET 요청과 비슷하지만 ResponseBody 없이 ResponseHeader만 반환할때 씀. 주로 리소스의 메타데이터(크기, 수정날짜 등)을 확인하기 위해 씀 (RequestBody X)
OPTIONS : 서버에서 리소스에 대한 가능한HTTP메서드나 통신 옵션을 확인하기 위해 씀. CORS와 관련있음 (RequestBody X)
CONNECT : 프록시 서버와의 터널을 설정하기 위해 씀. 주로 SSL/TLS의 암호화된 연결 설정에 씀
TRACE : 현재 서버와 경로를 따라 메시지를 다시 받기 위한 진단 목적. 디버깅과 관련있음 (RequestBody X)

----------------------------------------------------------------------------------------------------

URL 파라미터(URL Parameters)

쿼리파라미터와 패스 파라미터를 포함

---

패스 파라미터(Path Parameters)

URL 경로 내에 동적으로 변하는 값을 나타냄
경로 자체에 매개변수 값을 포함하여 전달함
주로 RESTful API에서 사용되며, 경로 일부에 변수를 삽입하는 형식으로 사용됨

https://example.com/users/12345
여기서 12345가 URL파라미터임

-----

쿼리 스트링(Query String) or 쿼리 파라미터(Query Parameters)

URL의 끝에 "?"로 시작하여 키-값 쌍으로 이루어진 문자열을 포함함
URL 파라미터와 마찬가지로 키-값 쌍으로 구성되며, 각 쌍은 "&"로 구분됨
주로 HTTP GET 요청에 사용되며, URL 끝에 쿼리 스트링을 추가함

https://example.com/path?key1=value1&key2=value2
여기서 ? 이후부터 쿼리 매개변수가 시작됨 key1=value1&key2=value2

----------------------------------------------------------------------------------------------------

클라이언트 / 서버

------------------------------

클라이언트

서비스나 리소스를 사용하거나 요청하는 역할

네트워크 또는 컴퓨팅 환경에서 서비스를 요청하거나 사용하는 주체로, 컴퓨터, 모바일 기기, 웹 브라우저, 애플리케이션 등에서 클아이언트 역할을 수행할 수 있음
서버에서 제공하는 서비스, 데이터 또는 리소스에 액세스하기 위해 사용자나 애플리케이션이 서버와 통신하는 역할을 함
(사용자 인터페이스(GUI) 역할 & 사용자의 입력을 처리하는 역할을 함)

ex) 웹 브라우저는 웹 서버와 통신하여 웹 페이지를 요청하고 표시하는 클라이언트 역할을 함
ex) 이메일 클라이언트는 이메일 서버와 통신하여 이메일을 송수신하고 표시함

------------------------------

서버

서비스를 제공하는 역할. 하드웨어 또는 소프트웨어 기반

데이터 처리, 비즈니스 로직, 데이터베이스와의 상호작용 등을 담당함
클라이언트로부터 요청을 받아서 처리하고, 결과 데이터를 클라이언트에게 전달함

------------------------------

하드웨어적인 서버 (위에서 말한 서버랑 의미는 상통함. 서버의 역할인데 그 안에서도 소프트웨어 말고 하드웨어에 대한 내용임)

특정 기능을 수행하기 위해 설계된 하드웨어와 소프트웨어의 조합

네트워크를 통해 클라이언트 컴퓨터나 다른 장치와 통신하고 정보나 서비스를 제공함
서버는 보통 더 안정적이고 성능이 뛰어난 하드웨어를 사용하며, 항상 켜져있거나 계속해서 가동되는 경우가 많음

이에 비해 클라이언트 컴퓨터는 주로 사용자가 작업을 수행하고 프로그램을 실행하는 데 사용되며, 필요에 따라 서버와 통신하여 정보를 받아옴

----------------------------------------------------------------------------------------------------

P2P

하나의 중앙 컴퓨터가 서버로 동작하는 것이 아니라, 모든 컴퓨터가 서로 서버 역할과 클라이언트 역할을 동시에 수행할 수 있는 분산 네트워크 시스템

Peer(피어. =또래, =동료)
피어는 일반적으로 동일한 네트워크 또는 시스템에 연결된 두 개 이상의 컴퓨터 또는 기기를 가리킴

각 피어는 동등한 지위를 가지며 서로 직접 통신할 수 있음

P2P 네트워크에서 다른 모든 피어가 컴퓨터를 끄면 파일을 받을 수 없게 됨
파일 공유를 위해서는 다른 피어가 활성화되어있어야함
파일을 제공하는 모든 피어가 오프라인 상태거나 네트워크에 연결되어 있지 않다면 파일을 받을 수 없게 됨

이런 이유로 P2P 네트워크에서는 파일을 공유하거나 다운로드할 때 사용 가능한 피어의 수가 중요함
더 많은 활성 피어가 있는 경우 파일을 빠르게 받을 수 있지만, 다운로드 가능한 피어의 수가 제한적인 경우 다운로드 속도가 느려질 수 있음

----------------------------------------------------------------------------------------------------

툴(도구) / 클라이언트

------------------------------

IDE(Integrated Development Environments, 통합 개발 환경)

-----

Visual Studio
Microsoft의 IDE로서 다양한 언어와 플랫폼을 지원함

IntelliJ IDEA
Java와 관련된 프로젝트를 개발하기 위한 IDE

Eclipse
Java 기반의 개발을 위한 무료 오픈 소스 IDE

Xcode
macOS 및 iOS 앱 개발을 위한 IDE

------------------------------

코드 편집기 (Code Editors)

Visual Studio Code
경량 코드 편집기로 다양한 언어를 지원하며 확장 기능을 통해 기능을 확장할 수 있음

Sublime Text
간단하면서도 강력한 코드 편집기로 다양한 플러그인을 지원함

EditPlus
윈도우용 텍스트 편집기 및 코드 편집 도구로 다양한 프로그래밍 언어와 파일 형식을 지원합니다

Atom
GitHub에서 개발한 코드 편집기로 커스터마이징이 용이함

------------------------------

버전 관리 (Version Control)

-----

Git
코드 버전 관리 시스템으로 협업 및 소스 코드 추적을 가능하게 함

SVN (Subversion)
중앙집중식 버전 관리 시스템으로 파일의 변화를 추적함

Mercurial
분산 버전 관리 시스템으로 Git과 비슷함

------------------------------

빌드 및 자동화

-----

Maven
Java 프로젝트의 의존성 관리와 빌드를 자동화함

Gradle
JVM 언어를 위한 빌드 도구로 Maven과 유사하지만 좀 더 유연함

Jenkins
지속적인 통합과 지속적인 배포 (CI/CD)를 위한 자동화 도구

------------------------------

DB 클라이언트

-----

MySQL Workbench
MySQL DB를 관리하고 시각화 하는 도구

pgAdmin
PostgreSQL DB를 관리하는 데 사용

Oracle SQL Developer
Oracle 데이터베이스를 관리하는 데 사용되는 공식 GUI 도구로, SQL 쿼리 개발 및 성능 모니터링을 지원함

MongoDB Compass
MongoDB 를 시각적으로 탐색하고 쿼리를 실행하는 데 사용되는 GUI 도구

SQL Server Management Studio (SSMS)
Microsoft SQL Server 데이터베이스를 관리하는 도구

DBeaver
다양한 데이터베이스 시스템을 지원하는 오픈 소스 데이터베이스 관리 도구로, 다양한 플러그인을 통해 확장 가능

DBeaver
다양한 데이터베이스 시스템을 지원하는 오픈 소스 데이터베이스 관리 도구로, 다양한 플러그인을 통해 확장 가능

Toad
Oracle, SQL Server, MySQL 및 다른 데이터베이스 시스템을 위한 상용 데이터베이스 관리 도구로, 개발자와 관리자를 위한 다양한 기능을 제공함

------------------------------

프로젝트 관리 및 협업 툴

JIRA
소프트웨어 개발 및 프로젝트 관리 도구로 Atlassian이 제공함

Slack
팀 간 커뮤니케이션을 위한 메시징 플랫폼

Trello
프로젝트 및 작업을 시각적으로 관리하는 협업 도구

------------------------------

테스트 및 디버깅 툴

Postman
API 테스트 및 디버깅을 위한 도구로 API 요청 및 응답을 테스트함

Selenium
웹 애플리케이션 테스트 자동화를 위한 도구

------------------------------

FTP 클라이언트

파일 전송 프로토콜(File Transfer Protocol)을 사용하여 파일을 업로드 및 다운로드하기 위한 도구

-----

FileZilla, WinSCP, Cyberduck 등

------------------------------

SSH 클라이언트

원격 서버에 안전하게 접속하기 위한 Secure Shell(SSH) 클라이언트

-----

PuTTY, OpenSSH, SecureCRT 등

------------------------------

웹 브라우저 클라이언트

페이지를 렌더링하고 웹 사이트에 액세스하기 위해 사용되는 클라이언트 응용 프로그램

-----

Google Chrome, Microsoft IE, Mozilla Firefox, Apple Safari, Microsoft Edge 등

------------------------------

데스크톱 애플리케이션 클라이언트

데스크톱 애플리케이션 클라이언트는 개인 컴퓨터나 노트북에서 실행되며, 사용자에게 그래픽 사용자 인터페이스(GUI)를 제공함

-----

워드 프로세서, 그래픽 디자인 소프트웨어, 게임 등

------------------------------

모바일 애플리케이션 클라이언트

모바일 애플리케이션 클라이언트는 스마트폰 또는 태블릿과 같은 모바일 기기에서 실행되며, 다양한 애플리케이션을 사용자에게 제공함

-----

iOS와 Android 플랫폼에서 동작하는 앱들이 모바일 애플리케이션 클라이언트에 해당함

------------------------------

이메일 클라이언트

이메일을 보내고 받는 데 사용되는 소프트웨어

-----

Microsoft Outlook, Mozilla Thunderbird, Apple Mail, Gmail 웹 클라이언트 등이 있습니다.

------------------------------

VPN 클라이언트

가상 사설 네트워크(VPN)에 연결하기 위한 도구로, 데이터 보안 및 개인 정보 보호를 제공함

-----

OpenVPN, Cisco AnyConnect, NordVPN 등

------------------------------

리모트 데스크톱 클라이언트

원격 컴퓨터에 접속하고 원격으로 데스크톱 화면을 제어하기 위한 도구

-----

TeamViewer, Microsoft Remote Desktop, VNC(Viewer) 등

------------------------------

화상 회의

-----

Zoom, Google Meet, Skype, Slack, Microsoft Teams, Cisco Webex 등

------------------------------

소셜 미디어 클라이언트

-----

Facebook, Twitter, Instagram, LinkedIn

------------------------------

게임 클라이언트

Steam, Battle.net Launcher, Epic Games Launcher

----------------------------------------------------------------------------------------------------

프레임워크

------------------------------

웹 프레임워크

-----

Spring Framework

Java 기반의 애플리케이션을 개발하기 위한 포괄적인 프레임워크
의존성 주입(Dependency Injection), 관점 지향 프로그래밍(Aspect-Oriented Programming), 데이터 액세스 및 웹 개발을 지원함
주로 엔터프라이즈 애플리케이션을 개발하는 데 사용됨

-----

Ruby on Rails

Ruby 기반의 한 웹 애플리케이션 개발을 위한 프레임워크. 간단히 Rails라고도 부름
개발자가 빠르게 웹 애플리케이션을 개발할 수 있도록 도와줌. 명시적인 규칙과 컨벤션을 따르며 생산성을 높이는 데 중점을 둠

-----

Django

Python 기반의 웹 애플리케이션 개발을 위한 고수준 프레임워크
데이터베이스 모델링, URL 라우팅, 사용자 인증 등 많은 기능을 내장하고 있음
웹 개발을 위한 많은 부분을 자동화하여 개발자가 집중할 수 있도록 함

-----

Angular

TypeScript 기반의 웹 애플리케이션 개발을 위한 프레임워크
단일 페이지 애플리케이션(Single Page Application, SPA)을 개발하는 데 사용됨
데이터 바인딩, 컴포넌트 기반 아키텍처, 라우팅 등을 지원함

-----

React

JavaScript 기반의 웹 프레임워크. Facebook에서 개발함
사용자 인터페이스(UI) 개발을 위한 라이브러리
컴포넌트 기반 접근 방식을 채택하고 가상 DOM을 사용하여 성능을 향상시킴
React Native를 통해 모바일 앱도 개발 가능함

-----

Vue.js

JavaScript 기반의 웹 프레임워크
웹 애플리케이션을 작은 단위로 개발할 수 있게 해주는 라이브러리
가볍고 빠르며 다른 프로젝트에 통합하기 쉬움

-----

Express.js

Node.js 기반의 웹 애플리케이션 개발을 위한 미니멀하고 유연한 웹 프레임워크
웹 서버 및 미들웨어를 쉽게 작성할 수 있으며 RESTful API 및 웹 애플리케이션을 빠르게 만들 수 있음

------------------------------

데이터베이스 프레임워크

-----

Hibernate

Java 개발에서 관계형 데이터베이스를 다루기 위한 ORM(Object-Relational Mapping) 프레임워크

-----

Entity Framework

Microsoft의 .NET 플랫폼에서 데이터베이스와 상호 작용하기 위한 ORM 프레임워크

------------------------------

테스트 자동화 프레임워크

-----

JUnit

Java 개발에서 단위 테스트를 작성하고 실행하기 위한 프레임워크

-----

Robot Framework

범용 테스트 자동화 프레임워크
다양한 테스트 유형을 지원

------------------------------

UI 프레임워크

-----

Electron

HTML, CSS 및 JavaScript를 사용하여 데스크톱 애플리케이션을 개발할 수 있는 오픈 소스 프레임워크입니다.

----------------------------------------------------------------------------------------------------

Apache HTTP Server

정적 파일 서비스 및 웹 서버 기능을 제공하는 오픈 소스 소프트웨어
HTML, CSS, JavaScript, 이미지 파일 등의 정적인 컨텐츠를 처리함
다양한 모듈을 사용하여 웹 서버의 기능을 확장할 수 있음
로드 밸런싱, 프록시 서버, SSL 암호화 등의 기능을 제공함
PHP, Perl, Python 등의 스크립트 언어를 지원함

Apache는 클라이언트로부터 HTTP 요청을 받아들이고, 웹 서버 기능을 수행하여 클라이언트에게 정적인 웹 페이지를 제공하는 역할을 함

-----

Tomcat

Java 애플리케이션을 실행하고, Java 웹 애플리케이션(웹 애플리케이션 아카이브, WAR 파일)을 배포하고 관리할 수 있음
Java EE(Enterprise Edition) 스펙을 준수하며, 서블릿 컨테이너로 동작함
동적인 콘텐츠 생성을 위해 Java 코드를 실행하고, 데이터베이스와의 상호작용 등을 처리할 수 있음

Java Servlet, JSP(Java Server Pages), Java WevSocket 등의 기술을 사용하여 동적인 웹 어플리케이션을 실행하는 웹 애플리케이션 서버

-----

일반적으로 Apache와 Tomcat은 함께 사용되어 정적인 콘텐츠와 동적인 웹 애플리케이션을 효과적으로 서비스하는 데 활용됨

----------------------------------------------------------------------------------------------------

웹 자원

웹에서 사용되는 모든 요소
웹 페이지, 이미지, 비디오, 오디오, CSS파일, JavaScript파일, XML, JSP파일, 데이터 파일 등 다양한 형태의 파일이나 데이터를 포함
웹 자원은 웹 서버에 저장되어 웹 브라우저를 통해 요청(request)과 응답(response)의 형태로 교환됨

웹 자원은 일반적으로 고유한 식별자인 URL(Uniform Resource Locator)을 가지고 있으며, 클라이언트(웹 브라우저)는 이 URL을 사용하여 웹 서버에 해당 자원을 요청함
웹 서버는 이 요청을 받아서 해당 자원을 찾고, 필요한 경우 웹 서버에서 클라이언트에게 해당 자원을 전송함

----------------------------------------------------------------------------------------------------

DB : 데이터의 집합이 저장되는 공간

DBMS : DB를 관리하기 위한 소프트웨어. DB를 생성, 조작, 관리, 제어하는 역할을 수행함
ex) Oracle, MySQL, SQL Server, PostgreSQL

DB 클라이언트 : DB 서버에 접속하여 DB 관리 및 쿼리 작업을 수행하는 도구. 각각의 DBMS에 특화된 클라이언트 도구가 제공됨
ex) SQL Developer(Oracle용), DBeaver, MySQL Workbench(MySQL용), pgAdmin(PostgreSQL용), SQL Server Management Studio(SSMS. MS SQL 용),
	Navicat, Toad

FTP 클라이언트 : FTP(File Transfer Protocol) 서버에 접속하여 파일을 업로드, 다운로드, 관리하는 도구
ex) FileZilla, WinSCP

SSH 클라이언트 : SSH(Secure Shell) 프로토콜을 사용하여 원격 서버에 안전하게 접속하고 명령어를 실행하는 도구
ex) PuTTY, OpenSSH

웹 API 클라이언트 : 웹 서비스나 API에 접속하여 데이터를 송수신하고 요청을 처리하는 도구
ex) Postman, Insomnia, cURL

이메일 클라이언트 : POP3, IMAP, SMTP 등의 프로토콜을 사용하여 이메일 서버에 접속하여 이메일을 송수신하고 관리함
ex) Microsoft Outlook, Mozilla Thunderbird, Apple Mail

----------------------------------------------------------------------------------------------------

Docker : 단일 호스트(물리적 or 가상의 컴퓨터)에서 여러 컨테이너를 관리하는 데 사용

Kubernetes : 여러 호스트(물리적 or 가상의 컴퓨터)에서 동작하는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하기 위한 플랫폼

----------------------------------------------------------------------------------------------------

Jira : 프로젝트 관리 및 이슈 추적 도구

소프트웨어 개발 프로세스 에서 이슈 관리, 작업 추적, 프로젝트 계획, 일정 관리, 버그 추적 등을 지원

-----

Confluence : 문서 작성 및 지식 공유를 위한 도구

문서를 작성하고 공유할 수 있으며, 여러 사용자가 동시에 문서를 편집하고 협업할 수 있음

-----

둘 다 Atlassian이라는 회사에서 개발한 협업 도구임

----------------------------------------------------------------------------------------------------

폴더 : 주로 윈도우에서 쓰는 용어

디렉토리 : Unix 및 Linux 운영체제에서 쓰는 용어

----------------------------------------------------------------------------------------------------

메시지 브로커

메시지를 받아서 적절히 처리하고 나면 즉시 or 짧은시간 내에 삭제됨

Redis queue, RabbitMQ

-----

이벤트 브로커

업무상 필요한 시간동안 이벤트를 보존할 수 있음

Kafka, AWS Kinesis

----------------------------------------------------------------------------------------------------

소켓

컴퓨터 네트워크에서 데이터를 주고받을 때 사용되는 일종의 통로나 연결점

간단히 말하면, 소켓은 컴퓨터나 장치 간에 데이터를 주고받는 방법 중 하나임
이것은 컴퓨터 사이에서 데이터를 주고받는 문을 열고 닫는 것과 유사하며, 데이터를 보내고 받을 때 사용됨
예를 들어, 웹 브라우저가 웹 서버에 요청을 보내거나, 이메일 클라이언트가 이메일 서버로부터 이메일을 받아올 때, 이러한 통신에 소켓이 사용됨

----------------------------------------------------------------------------------------------------

OOP(객체 지향 설계)의 SOLID 원칙

------------------------------

SRP(단일 책임의 원칙, Single Responsibility Principle)

자동차를 만들고 있다고 가정해볼때, 여러 부품을 조립해야함

각 부품은 자신만의 역할을 수행해야함

엔진: 엔진은 자동차의 동력을 생성하는 역할만 해야함. 즉, 엔진은 주행에 필요한 동력을 만들고 다른 것과는 관련이 없어야 함
핸들과 방향 시스템: 핸들과 방향 시스템은 자동차를 운전하는 데 사용됨. 그러나 이 부분은 자동차 엔진을 개발하는 동안 생각할 필요가 없음. 각 부품은 자신의 책임을 갖고 있음
라디오 및 오디오 시스템: 라디오와 오디오 시스템은 음악을 재생하거나 라디오를 듣는 데 사용됨. 자동차 엔진과는 아무 상관이 없음

이와 같이 자동차 부품은 각각 하나의 주요 책임을 갖고 있으며, 다른 부품과는 무관한 일을 수행함. 이것이 단일 책임의 원칙임
클래스나 모듈도 비슷하게 설계해야함. 한 클래스나 모듈은 하나의 주요 작업 또는 책임만 가져야 하며 다른 작업과는 분리되어야함

이렇게 하면 코드가 더 이해하기 쉬워지고 유지보수가 간편해짐

------------------------------

OCP(개방 폐쇄 원칙, Open Closed Priciple)

소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 개방적이어야 하고, 수정에 대해서는 폐쇄적이어야 한다는 원칙
즉, 새로운 기능을 추가하거나 변경할 때 기존 코드를 수정하지 말고, 기존 코드를 확장하여 새로운 기능을 추가할 수 있어야 함

예를들어 아래와 같은 클래스가 있다고 할때
class Calculator {
    double calculateCircleArea(Circle circle) {
        // 원의 면적 계산 로직
    }

    double calculateRectangleArea(Rectangle rectangle) {
        // 사각형의 면적 계산 로직
    }

    double calculateTriangleArea(Triangle triangle) {
        // 삼각형의 면적 계산 로직
    }
}

새로운 도형인 '타원'을 추가하려면 Calculator클래스를 수정해야함. 이것은 OCP에 어긋나는 것임

OPC를 준수하게 되면 아래와 같음
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    // 원의 면적 계산 로직
    @Override
    public double calculateArea() {
        // ...
    }
}

class Rectangle implements Shape {
    // 사각형의 면적 계산 로직
    @Override
    public double calculateArea() {
        // ...
    }
}

class Triangle implements Shape {
    // 삼각형의 면적 계산 로직
    @Override
    public double calculateArea() {
        // ...
    }
}

class Calculator {
    double calculateArea(Shape shape) {
        return shape.calculateArea();
    }
}

------------------------------

LSP(리스코프 치환 원칙, Listov Substitution Priciple)

하위 타입은 그 상위 타입으로 대체 가능해야 함

<LSP를 준수한 경우>
class Animal {
    void makeSound() {
        System.out.println("동물이 소리를 낸다.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("개가 멍멍 짖는다.");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("고양이가 야옹야옹 운다.");
    }
}

위 코드에서 Animal클래스는 동물이 가질 수 있는 makeSound메서드를 가지고 있음. Dog과 Cat클래스는 이 메서드를 상속받아서 자신의 방식으로 오버라이드함.
이 경우, Animal을 상속받은 하위 클래스는 Animal대신 사용할 수 있으며, 예상한 대로 동작함


<LSP를 위반한 경우>
class Animal {
    void makeSound() {
        System.out.println("동물이 소리를 낸다.");
    }
}

class Bird extends Animal {
    @Override
    void makeSound() {
        System.out.println("새가 지저귄다.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("개가 멍멍 짖는다.");
    }
}

위 코드에서 Bird가 Animal클래스를 상속받고 있음. 그러나 새는 소리를 내는 방식이 다르기 때문에(일반적인 동물이 소리를 내는것과 방식이 다르기 때문에 "동물이 소리를 낸다" 가 될수 없음)
makeSound 메서드를 오버라이드하면서 LSP를 위반함
따라서 Bird객체를 Animal대신 사용하면 예상치 않은 결과가 발생할 수 있음

LSP를 준수하는경우, 상속 관계에서 하위 클래스는 상위 클래스의 메서드를 오버라이드할 수 있고, 이를 대체하여 사용할 때 예상한 대로 동작해야 함
LSP를 위반하면 상속 관계의 의미가 퇴색되고 예기치 않은 동작을 초래할 수 있음

------------------------------

ISP(인터페이스 분리 원칙, Interface Segregation Principle)

클라이언트가 사용하지 않는 메서드에 의존하게 만들어서는 안됨. 즉, 클라이언트가 필요로 하지 않는 메서드에 의존하지 말아야 한다는 원칙

<ISP를 준수하지 않는 설계>
interface Machine {
    void print(Document d);
    void scan(Document d);
    void fax(Document d);
}

class MultiFunctionPrinter implements Machine {
    public void print(Document d) {
        // 문서를 출력하는 로직
    }

    public void scan(Document d) {
        // 문서를 스캔하는 로직
    }

    public void fax(Document d) {
        // 문서를 팩스하는 로직
    }
}

class OldFashionedPrinter implements Machine {
    public void print(Document d) {
        // 문서를 출력하는 로직
    }

    public void scan(Document d) {
        // 아무런 스캔 기능이 없음
    }

    public void fax(Document d) {
        // 아무런 팩스 기능이 없음
    }
}

위의 코드에서 OldFashionedPrinter(구식프린터) 클래스는 스캔 및 팩스 기능이 필요없는 경우에도 이러한 메서드를 구현해야함
이는 ISP를 위반한 것

ISP를 준수하기 위해서 더 작은 단위로 분리해야함
interface Printer {
    void print(Document d);
}

interface Scanner {
    void scan(Document d);
}

interface Fax {
    void fax(Document d);
}

class MultiFunctionMachine implements Printer, Scanner, Fax {
    public void print(Document d) {
        // 문서를 출력하는 로직
    }

    public void scan(Document d) {
        // 문서를 스캔하는 로직
    }

    public void fax(Document d) {
        // 문서를 팩스하는 로직
    }
}

class OldFashionedPrinter implements Printer {
    public void print(Document d) {
        // 문서를 출력하는 로직
    }
}

------------------------------

DIP(의존 역전 원칙, Dependency Inversion Principle)

고수준 모듈은 저수준 모듈에 의존해서는 안되며, 양쪽 추상화에 의존해야 함. 즉, 구체적인 구현이 아닌 추상적인 인터페이스나 추상 클래스에 의존해야함

고수준 모듈: 응용 프로그램의 핵심 비즈니스 로직을 담당하며, 저수준 모듈을 활용하여 작업을 수행함
저수준 모듈: 고수준 모듈 또는 다른 저수준 모듈이 의존하는(필요로 하는), 하위 수준의 작업을 수행하는 모듈임

커피머신을 사용하는 커피자동주문시스템을 만들려고 한다고 할때
이 시스템은 커피머신을 조작하고 주문을 처리하는 기능을 제공함

<DIP를 위반하는 설계>
class CoffeeMachine {
    void brewCoffee() {
        // 커피를 내리는 로직
    }
}

class CoffeeOrderSystem {
    private CoffeeMachine coffeeMachine = new CoffeeMachine();

    void takeOrder() {
        // 주문을 받는 로직
        coffeeMachine.brewCoffee(); // 커피를 내림
    }
}

위 코드에서 CoffeeOrderSystem 클래스는 CoffeeMachine클래스에 직접 의존하고 있음. 이것은 DIP를 위반하는 것임
고수준 모듈인 CoffeeOrderSystem이 저수준 모듈인 CoffeeMachine에 의존하고 있음


<DIP를 준수하는 설계>
interface CoffeeMaker {
    void brew();
}

class CoffeeMachine implements CoffeeMaker {
    public void brew() {
        // 커피를 내리는 로직
    }
}

class CoffeeOrderSystem {
    private CoffeeMaker coffeeMaker;

    CoffeeOrderSystem(CoffeeMaker coffeeMaker) {
        this.coffeeMaker = coffeeMaker;
    }

    void takeOrder() {
        // 주문을 받는 로직
        coffeeMaker.brew(); // 커피를 내림
    }
}

이번에는 CoffeeMaker 인터페이스를 도입하고, CoffeeMachine 클래스가 이 인터페이스를 구현합니다. CoffeeOrderSystem 클래스는 이제 CoffeeMaker 인터페이스에 의존하고 있습니다. 이렇게 하면 고수준 모듈인 CoffeeOrderSystem이 저수준 모듈인 CoffeeMachine에 직접 의존하지 않고, 추상화에 의존하게 됩니다.

DIP를 준수하는 설계에서는 커피 머신이 아닌 다른 커피 메이커를 손쉽게 연결하고 사용할 수 있으며, 시스템이 더 유연하고 확장 가능해집니다.

------------------------------

'좋은 설계'란 시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조를 말함
그래서 시스템에 예상하지 못한 변경사항이 발생하더라도, 유연하게 대처하고 이후에 확장성이 있는 시스템 구조를 만들 수 있음

즉 SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지보수 관리하기가 더 쉬워지며, 불필요한 복잡성을 제거해 프로젝트 개발의 생산성을 높일 수 있음

----------------------------------------------------------------------------------------------------

컨테이너 기술

컨테이너 기술은 하나의 물리적 또는 가상 서버에서 여러 개의 격리된 컨테이너를 실행할 수 있도록 해줌
즉 컴퓨터 형태에 영향을 받지 않으며, 어디서든 실행이 가능함

ex) 도커(Docker), 쿠버네티스(Kubernetes)

------------------------------

컨테이너 기술의 장점


격리: 각 컨테이너는 호스트 시스템 & 다른 컨테이너와 완전히 격리된 환경에서 실행됨. 이를 통해 애플리케이션간의 충돌을 방지하고, 서로 독립적으로 운영할 수 있음

이식성: 컨테이너 이미지는 마치 휴대용 박스라고 생각할 수 있음. 이 박스 안에는 애플리케이션과 그 모든 필요한 부품(라이브러리, 설정 등)이 들어있음
컨테이너 이미지를 한 곳에서 만들어서 어디든 가져갈 수 있음
즉, 개발자가 로컬 컴퓨터에서 어플리케이션을 개발하고, 그 이미지를 서버로, 클라우드로, 또는 다른 컴퓨터로 쉽게 이동할 수 있음
컨테이너 이미지는 실행환경을 포함하기 때문에, 호스트 시스템의 설정과 상관없이 일관된 방식으로 작동함


이 밖에도 확장성, 빠른 시작과 종료, 자동화, 자원 효율, 빠른 개발 및 배포 와 같은 장점들이 있음

------------------------------

이미지: 클래스
컨테이너: 인스턴스

------------------------------

컨테이너 오케스트레이션 도구

여러개의 서버와 그 안에 있는 컨테이너들을 효율적으로 관리하기 위해 사용하는 플랫폼임

컨테이너의 상태를 모니터링하고 필요에 따라 컨테이너를 다시 시작하거나 재배포할 수 있음

스케일링: Kubernetes는 트래픽 또는 작업 부하에 따라 컨테이너 수를 동적으로 확장하거나 축소할 수 있습니다. 이로써 애플리케이션의 가용성과 성능을 유지할 수 있습니다.
서비스 관리: Kubernetes는 서비스 디스커버리와 로드 밸런싱을 제공하여 컨테이너 간 통신을 관리하고 클라이언트가 서비스를 찾고 사용할 수 있도록 합니다.
자동 복구: 컨테이너나 노드의 장애가 발생했을 때, Kubernetes는 자동으로 장애를 감지하고 해당 컨테이너를 다른 노드로 재배포하여 애플리케이션의 고가용성을 보장합니다.
설정 관리: Kubernetes는 컨테이너의 설정을 중앙에서 관리하고 업데이트할 수 있습니다. 이를 통해 애플리케이션의 동작을 유연하게 변경할 수 있습니다.
롤링 업데이트: 새로운 버전의 애플리케이션을 배포할 때 Kubernetes는 롤링 업데이트를 통해 서비스 중단 없이 안정적으로 업데이트할 수 있습니다.

ex) 쿠버네티스(Kubernetes), 도커 스웜(Docker Swarm)

------------------------------

DB는 컨테이너에 안넣는게 좋음





























